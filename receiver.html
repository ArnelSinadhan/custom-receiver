<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Takokase Custom Receiver - Enhanced Debug</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background-color: #000000;
        font-family: "Arial", sans-serif;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }

      /* Cast media player */
      cast-media-player {
        width: 100%;
        height: 100%;
        --splash-image: none;
        --progress-color: #667eea;
        --theme-hue: 250;
        --logo-image: none;
      }

      /* Splash screen overlay */
      #splash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #107f48;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        transition: opacity 0.5s ease-out;
      }

      #splash.hidden {
        opacity: 0;
        pointer-events: none;
      }

      #splash h1 {
        font-size: 72px;
        color: #ffffff;
        font-weight: bold;
        text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
      }

      #splash p {
        font-size: 24px;
        color: #ffffff;
        opacity: 0.9;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #ffffff;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin-top: 30px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* Enhanced Debug overlay with scrolling */
      #debug {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.95);
        color: #00ff00;
        padding: 15px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        border-radius: 8px;
        z-index: 500;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        border: 2px solid #00ff00;
      }

      #debug.hidden {
        display: none;
      }

      #debug h3 {
        color: #00ff00;
        margin-bottom: 10px;
        font-size: 16px;
        border-bottom: 1px solid #00ff00;
        padding-bottom: 5px;
      }

      #debug .section {
        margin-bottom: 15px;
      }

      #debug .label {
        color: #ffff00;
        font-weight: bold;
      }

      #debug .value {
        color: #00ff00;
      }

      #debug .error {
        color: #ff0000;
        font-weight: bold;
      }

      #debug .success {
        color: #00ff00;
        font-weight: bold;
      }

      #debug .warning {
        color: #ffa500;
        font-weight: bold;
      }

      #debug .log-entry {
        margin: 5px 0;
        padding: 5px;
        background: rgba(0, 255, 0, 0.05);
        border-left: 2px solid #00ff00;
        padding-left: 10px;
        font-size: 11px;
      }

      #debug .log-entry.error {
        border-left-color: #ff0000;
        background: rgba(255, 0, 0, 0.05);
      }

      #debug .log-entry.warning {
        border-left-color: #ffa500;
        background: rgba(255, 165, 0, 0.05);
      }

      #debug .log-entry.success {
        border-left-color: #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }

      #debug .timestamp {
        color: #888;
        font-size: 10px;
      }

      /* Log container */
      #log-container {
        max-height: 300px;
        overflow-y: auto;
        margin-top: 10px;
        border-top: 1px solid #00ff00;
        padding-top: 10px;
      }

      /* Scrollbar styling */
      #debug::-webkit-scrollbar,
      #log-container::-webkit-scrollbar {
        width: 8px;
      }

      #debug::-webkit-scrollbar-track,
      #log-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.5);
      }

      #debug::-webkit-scrollbar-thumb,
      #log-container::-webkit-scrollbar-thumb {
        background: #00ff00;
        border-radius: 4px;
      }

      /* Make URLs and long text wrap properly */
      #server-url,
      #key-url {
        word-break: break-all;
        font-size: 10px;
        color: #00ff00;
      }
    </style>
  </head>
  <body>
    <!-- Splash Screen -->
    <div id="splash">
      <h1>Takokase</h1>
      <p id="splash-text">Ready to Cast</p>
      <div class="spinner"></div>
    </div>

    <!-- Cast Media Player -->
    <cast-media-player></cast-media-player>

    <!-- Enhanced Debug Info -->
    <div id="debug">
      <h3>üéØ Takokase Receiver Debug</h3>

      <div class="section">
        <div>
          <span class="label">Status:</span>
          <span id="status" class="value">Initializing...</span>
        </div>
        <div>
          <span class="label">Player State:</span>
          <span id="state" class="value">IDLE</span>
        </div>
        <div>
          <span class="label">Media Type:</span>
          <span id="media-type" class="value">-</span>
        </div>
      </div>

      <div class="section">
        <div><span class="label">üì° Server URL:</span></div>
        <div id="server-url" class="value">Not loaded</div>
      </div>

      <div class="section">
        <div>
          <span class="label">üéµ Audio Tracks:</span>
          <span id="audio-tracks" class="value">0</span>
        </div>
        <div>
          <span class="label">üìù Text Tracks:</span>
          <span id="text-tracks" class="value">0</span>
        </div>
        <div>
          <span class="label">üé¨ Video Tracks:</span>
          <span id="video-tracks" class="value">0</span>
        </div>
      </div>

      <div class="section">
        <div>
          <span class="label">üîê Encryption:</span>
          <span id="encryption" class="value">Unknown</span>
        </div>
        <div><span class="label">üîë Key URL:</span></div>
        <div id="key-url" class="value">Not detected</div>
      </div>

      <div class="section">
        <div>
          <span class="label">üìä Current Segment:</span>
          <span id="current-segment" class="value">-</span>
        </div>
        <div>
          <span class="label">‚è±Ô∏è Playback Time:</span>
          <span id="playback-time" class="value">0:00</span>
        </div>
        <div>
          <span class="label">üì∂ Buffer:</span>
          <span id="buffer-level" class="value">0%</span>
        </div>
      </div>

      <div class="section">
        <div><span class="label">‚ùå Last Error:</span></div>
        <div id="last-error" class="error">None</div>
      </div>

      <div class="section">
        <div><span class="label">üìú Event Log:</span></div>
        <div id="log-container"></div>
      </div>
    </div>

    <!-- Cast Receiver SDK -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

    <!-- Enhanced Receiver Logic -->
    <script>
      const DEBUG = true;
      const LOG_PREFIX = "[Takokase]";
      const MAX_LOG_ENTRIES = 50;

      let logEntries = [];
      let segmentCount = 0;
      let lastSegmentUrl = "";

      // ============================================
      // LOGGING FUNCTIONS
      // ============================================

      function getTimestamp() {
        const now = new Date();
        return (
          now.toLocaleTimeString() +
          "." +
          now.getMilliseconds().toString().padStart(3, "0")
        );
      }

      function log(...args) {
        const timestamp = getTimestamp();
        const message = args.join(" ");
        console.log(LOG_PREFIX, timestamp, ...args);
        addLogEntry(message, "info");
      }

      function logError(...args) {
        const timestamp = getTimestamp();
        const message = args.join(" ");
        console.error(LOG_PREFIX, timestamp, ...args);
        addLogEntry(message, "error");
      }

      function logWarning(...args) {
        const timestamp = getTimestamp();
        const message = args.join(" ");
        console.warn(LOG_PREFIX, timestamp, ...args);
        addLogEntry(message, "warning");
      }

      function logSuccess(...args) {
        const timestamp = getTimestamp();
        const message = args.join(" ");
        console.log(LOG_PREFIX, "‚úÖ", timestamp, ...args);
        addLogEntry(message, "success");
      }

      function addLogEntry(message, type = "info") {
        const timestamp = getTimestamp();
        logEntries.unshift({ timestamp, message, type });

        // Keep only last MAX_LOG_ENTRIES
        if (logEntries.length > MAX_LOG_ENTRIES) {
          logEntries = logEntries.slice(0, MAX_LOG_ENTRIES);
        }

        updateLogDisplay();
      }

      function updateLogDisplay() {
        const container = document.getElementById("log-container");
        if (!container) return;

        container.innerHTML = logEntries
          .map((entry) => {
            const className = entry.type;
            return `<div class="log-entry ${className}">
            <span class="timestamp">[${entry.timestamp}]</span> ${entry.message}
          </div>`;
          })
          .join("");

        // Auto-scroll to top (newest entries)
        container.scrollTop = 0;
      }

      // ============================================
      // DEBUG UI UPDATE FUNCTIONS
      // ============================================

      function updateDebug(key, value, className = "value") {
        const el = document.getElementById(key);
        if (el) {
          el.textContent = value;
          el.className = className;
        }
      }

      function updateServerUrl(url) {
        updateDebug("server-url", url);
        log("üì° Server URL:", url);
      }

      function updateMediaType(type) {
        updateDebug("media-type", type);
      }

      function updateEncryption(hasEncryption, keyUrl = null) {
        if (hasEncryption) {
          updateDebug("encryption", "AES-128 ‚úì", "success");
          if (keyUrl) {
            updateDebug("key-url", keyUrl);
            log("üîë Encryption Key URL:", keyUrl);
          }
        } else {
          updateDebug("encryption", "None", "value");
        }
      }

      function updateLastError(error) {
        if (error) {
          updateDebug("last-error", error, "error");
          logError("‚ùå ERROR:", error);
        } else {
          updateDebug("last-error", "None", "success");
        }
      }

      function updatePlaybackTime(currentTime, duration) {
        const formatTime = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, "0")}`;
        };

        const timeStr = duration
          ? `${formatTime(currentTime)} / ${formatTime(duration)}`
          : formatTime(currentTime);

        updateDebug("playback-time", timeStr);
      }

      // ============================================
      // SPLASH SCREEN FUNCTIONS
      // ============================================

      function hideSplash() {
        const splash = document.getElementById("splash");
        splash.classList.add("hidden");
        log("‚úÖ Splash screen hidden - Media ready");
      }

      function updateSplashText(text) {
        const splashText = document.getElementById("splash-text");
        if (splashText) splashText.textContent = text;
        log("üí¨ Splash:", text);
      }

      // ============================================
      // MEDIA ANALYSIS FUNCTIONS
      // ============================================

      function analyzeMediaInfo(mediaInfo) {
        if (!mediaInfo) {
          logWarning("‚ö†Ô∏è No media info available");
          return;
        }

        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        log("üìä MEDIA INFORMATION ANALYSIS");
        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        // Content URL
        if (mediaInfo.contentId) {
          const url = mediaInfo.contentId;
          updateServerUrl(url);

          // Extract server base URL
          try {
            const urlObj = new URL(url);
            const serverBase = `${urlObj.protocol}//${urlObj.host}`;
            log("üè† Server Base:", serverBase);

            // Check if it's HLS
            if (url.includes(".m3u8")) {
              log("üì∫ Format: HLS (HTTP Live Streaming)");
              updateMediaType("HLS");
            }
          } catch (e) {
            logError("Failed to parse URL:", e.message);
          }
        }

        // Content Type
        if (mediaInfo.contentType) {
          log("üìÑ Content-Type:", mediaInfo.contentType);

          if (
            mediaInfo.contentType.includes("mpegurl") ||
            mediaInfo.contentType.includes("x-mpegurl")
          ) {
            log("‚úÖ Valid HLS content type detected");
          }
        }

        // Tracks
        if (mediaInfo.tracks && mediaInfo.tracks.length > 0) {
          log("üéµ Tracks found:", mediaInfo.tracks.length);

          let audioCount = 0;
          let textCount = 0;
          let videoCount = 0;

          mediaInfo.tracks.forEach((track, index) => {
            const typeStr =
              track.type === 1
                ? "TEXT"
                : track.type === 2
                ? "AUDIO"
                : track.type === 3
                ? "VIDEO"
                : "UNKNOWN";

            log(
              `  Track ${index}: ${typeStr} - ${track.name || "Unnamed"} (${
                track.language || "no-lang"
              })`
            );

            if (track.type === 2) audioCount++;
            if (track.type === 1) textCount++;
            if (track.type === 3) videoCount++;
          });

          updateDebug("audio-tracks", audioCount);
          updateDebug("text-tracks", textCount);
          updateDebug("video-tracks", videoCount);
        } else {
          log("‚ö†Ô∏è No tracks information in media");
          updateDebug("audio-tracks", 0);
          updateDebug("text-tracks", 0);
          updateDebug("video-tracks", 0);
        }

        // Custom Data
        if (mediaInfo.customData) {
          log("üì¶ Custom Data:", JSON.stringify(mediaInfo.customData, null, 2));
        }

        // Metadata
        if (mediaInfo.metadata) {
          log("üìù Metadata:", {
            title: mediaInfo.metadata.title,
            subtitle: mediaInfo.metadata.subtitle,
          });
        }

        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
      }

      function analyzeHLSPlaylist(url) {
        log("üîç Attempting to fetch and analyze HLS playlist...");

        fetch(url)
          .then((response) => {
            log(
              `üì° Playlist fetch response: ${response.status} ${response.statusText}`
            );

            if (!response.ok) {
              logError(`‚ùå Failed to fetch playlist: ${response.status}`);
              return null;
            }

            return response.text();
          })
          .then((playlistContent) => {
            if (!playlistContent) return;

            log("‚úÖ Playlist fetched successfully");
            log("üìÑ Playlist size:", playlistContent.length, "bytes");

            // Check for encryption
            if (playlistContent.includes("#EXT-X-KEY")) {
              logWarning("üîê ENCRYPTION DETECTED in playlist");

              const keyMatch = playlistContent.match(
                /#EXT-X-KEY:METHOD=([^,]+),URI="([^"]+)"/
              );
              if (keyMatch) {
                const method = keyMatch[1];
                const keyUrl = keyMatch[2];
                log(`  Method: ${method}`);
                log(`  Key URL: ${keyUrl}`);
                updateEncryption(true, keyUrl);

                // Test key accessibility
                testKeyUrl(keyUrl);
              }
            } else {
              log("‚úÖ No encryption detected");
              updateEncryption(false);
            }

            // Check for segments
            const segmentMatches = playlistContent.match(/^[^#].*\.ts$/gm);
            if (segmentMatches) {
              log(`üì¶ Found ${segmentMatches.length} segment references`);
              log(`  First segment: ${segmentMatches[0]}`);
            }

            // Check for audio renditions
            const audioMatches = playlistContent.match(
              /#EXT-X-MEDIA:TYPE=AUDIO.*/g
            );
            if (audioMatches) {
              log(
                `üéµ Found ${audioMatches.length} audio renditions in master playlist`
              );
              audioMatches.forEach((match, i) => {
                const langMatch = match.match(/LANGUAGE="([^"]+)"/);
                const nameMatch = match.match(/NAME="([^"]+)"/);
                if (langMatch && nameMatch) {
                  log(`  Audio ${i + 1}: ${nameMatch[1]} (${langMatch[1]})`);
                }
              });
            }
          })
          .catch((error) => {
            logError("‚ùå Failed to fetch playlist:", error.message);
            logError("  This could indicate:");
            logError("  - Server not accessible from Chromecast");
            logError("  - CORS headers missing");
            logError("  - Network connectivity issue");
          });
      }

      function testKeyUrl(keyUrl) {
        log("üîë Testing encryption key accessibility...");

        fetch(keyUrl)
          .then((response) => {
            log(
              `  Key fetch response: ${response.status} ${response.statusText}`
            );

            if (!response.ok) {
              logError(`  ‚ùå Key not accessible: ${response.status}`);
              return null;
            }

            return response.arrayBuffer();
          })
          .then((keyData) => {
            if (!keyData) return;

            log(`  ‚úÖ Key fetched successfully`);
            log(`  Key size: ${keyData.byteLength} bytes`);

            if (keyData.byteLength !== 16) {
              logError(
                `  ‚ö†Ô∏è WARNING: Key size is ${keyData.byteLength} bytes, expected 16 bytes for AES-128`
              );
            } else {
              logSuccess("  ‚úÖ Key size is correct (16 bytes)");
            }
          })
          .catch((error) => {
            logError("  ‚ùå Failed to fetch key:", error.message);
            logError("  CRITICAL: Encrypted content cannot play without key!");
          });
      }

      // ============================================
      // SEGMENT MONITORING
      // ============================================

      function monitorSegments(mediaElement) {
        if (!mediaElement) return;

        // Monitor progress to detect segment changes
        let lastLogTime = 0;

        mediaElement.addEventListener("progress", () => {
          const now = Date.now();
          if (now - lastLogTime > 2000) {
            // Log every 2 seconds
            lastLogTime = now;

            const buffered = mediaElement.buffered;
            if (buffered.length > 0) {
              const bufferEnd = buffered.end(buffered.length - 1);
              const currentTime = mediaElement.currentTime;
              const bufferAhead = bufferEnd - currentTime;

              updateDebug("buffer-level", `${bufferAhead.toFixed(1)}s`);

              if (bufferAhead < 5) {
                logWarning(`‚ö†Ô∏è Low buffer: ${bufferAhead.toFixed(1)}s ahead`);
              }
            }
          }
        });

        // Monitor time updates
        mediaElement.addEventListener("timeupdate", () => {
          const currentTime = mediaElement.currentTime;
          const duration = mediaElement.duration;

          if (!isNaN(currentTime) && !isNaN(duration)) {
            updatePlaybackTime(currentTime, duration);
          }
        });

        // Monitor segment loading (approximation based on time)
        let lastSegmentTime = 0;
        mediaElement.addEventListener("timeupdate", () => {
          const currentTime = mediaElement.currentTime;
          const segmentDuration = 10; // Assume 10-second segments
          const currentSegment = Math.floor(currentTime / segmentDuration);

          if (currentSegment !== lastSegmentTime) {
            lastSegmentTime = currentSegment;
            segmentCount++;
            updateDebug("current-segment", `#${currentSegment}`);
            log(
              `üì¶ Playing segment: #${currentSegment} (~${currentTime.toFixed(
                1
              )}s)`
            );
          }
        });

        // Monitor waiting (buffering)
        mediaElement.addEventListener("waiting", () => {
          logWarning("‚è∏Ô∏è Buffering...");
          updateDebug("state", "BUFFERING", "warning");
        });

        // Monitor playing resumed
        mediaElement.addEventListener("playing", () => {
          logSuccess("‚ñ∂Ô∏è Playback resumed");
          updateDebug("state", "PLAYING", "success");
        });

        // Monitor stalls
        mediaElement.addEventListener("stalled", () => {
          logWarning("‚ö†Ô∏è Network stall detected");
        });

        // Monitor errors on media element
        mediaElement.addEventListener("error", (e) => {
          const error = mediaElement.error;
          if (error) {
            const errorCodes = {
              1: "MEDIA_ERR_ABORTED",
              2: "MEDIA_ERR_NETWORK",
              3: "MEDIA_ERR_DECODE",
              4: "MEDIA_ERR_SRC_NOT_SUPPORTED",
            };

            const errorMsg =
              errorCodes[error.code] || `Unknown error ${error.code}`;
            logError(`‚ùå Media Element Error: ${errorMsg}`);
            logError(`   Message: ${error.message || "No message"}`);
            updateLastError(`${errorMsg}: ${error.message || "No details"}`);
          }
        });

        log("‚úÖ Segment monitoring enabled");
      }

      // ============================================
      // ERROR ANALYSIS
      // ============================================

      function analyzeError(event) {
        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        log("‚ùå ERROR EVENT RECEIVED");
        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");

        const errorCode = event.detailedErrorCode;
        const error = event.error;

        log("Error Code:", errorCode);

        if (error) {
          log("Error Reason:", error.reason);
          log("Error Type:", error.type);
          log("Error Details:", JSON.stringify(error, null, 2));
        }

        // Error 905 specific analysis
        if (errorCode === 905) {
          logError("üö® ERROR 905: MEDIA_ERROR_DECODE");
          logError("This typically means:");
          logError("  1. Content format not supported by receiver");
          logError("  2. Encryption/DRM issue");
          logError("  3. Corrupted media data");
          logError("  4. Missing or inaccessible encryption key");
          logError("");
          logError("TROUBLESHOOTING:");
          logError("  ‚úì Check if encryption key URL is accessible");
          logError("  ‚úì Verify key returns exactly 16 bytes");
          logError("  ‚úì Check CORS headers on server");
          logError("  ‚úì Test with default receiver");
          logError("  ‚úì Verify HLS playlist format");
        }

        // Network errors
        if (errorCode >= 900 && errorCode < 1000) {
          logError("üåê Network-related error");
          logError("  - Check Chromecast can reach server");
          logError("  - Verify same network/no firewall");
          logError("  - Check server logs for requests");
        }

        updateLastError(`Error ${errorCode}: ${error?.reason || "Unknown"}`);
        updateDebug("state", `ERROR ${errorCode}`, "error");

        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
      }

      // ============================================
      // RECEIVER INITIALIZATION
      // ============================================

      try {
        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        log("üöÄ INITIALIZING TAKOKASE RECEIVER");
        log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        log("Receiver version: Enhanced Debug v2.0");
        log("Debug mode:", DEBUG ? "ENABLED" : "DISABLED");

        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();

        // Configure options for encrypted content
        const options = new cast.framework.CastReceiverOptions();
        options.disableIdleTimeout = false;
        options.maxInactivity = 3600;

        log("‚úÖ Receiver options configured");

        // ============================================
        // EVENT LISTENERS
        // ============================================

        // PLAYER_LOADING
        playerManager.addEventListener(
          cast.framework.events.EventType.PLAYER_LOADING,
          (event) => {
            log("‚è≥ PLAYER_LOADING event received");
            updateSplashText("Loading Media...");
            updateDebug("state", "LOADING", "warning");
            updateDebug("status", "Loading...", "warning");
          }
        );

        // PLAYER_LOAD_COMPLETE
        playerManager.addEventListener(
          cast.framework.events.EventType.PLAYER_LOAD_COMPLETE,
          (event) => {
            logSuccess("‚úÖ PLAYER_LOAD_COMPLETE - Media loaded successfully!");
            hideSplash();
            updateDebug("state", "LOADED", "success");
            updateDebug("status", "Playing", "success");

            // Analyze media info
            const mediaInfo = playerManager.getMediaInformation();
            if (mediaInfo) {
              analyzeMediaInfo(mediaInfo);

              // Fetch and analyze playlist if HLS
              if (
                mediaInfo.contentId &&
                mediaInfo.contentId.includes(".m3u8")
              ) {
                analyzeHLSPlaylist(mediaInfo.contentId);
              }
            }

            // Monitor segments
            const mediaElement = playerManager.getMediaElement();
            if (mediaElement) {
              monitorSegments(mediaElement);
            }
          }
        );

        // ERROR
        playerManager.addEventListener(
          cast.framework.events.EventType.ERROR,
          (event) => {
            analyzeError(event);
            hideSplash();
          }
        );

        // MEDIA_STATUS
        playerManager.addEventListener(
          cast.framework.events.EventType.MEDIA_STATUS,
          (event) => {
            const mediaStatus = event.mediaStatus;
            if (mediaStatus) {
              const playerState = mediaStatus.playerState;
              log(`üìä Media Status: ${playerState}`);
              updateDebug("state", playerState);
            }
          }
        );

        // BITRATE_CHANGED
        playerManager.addEventListener(
          cast.framework.events.EventType.BITRATE_CHANGED,
          (event) => {
            log(`üì∂ Bitrate changed: ${event.totalBitrate} bps`);
          }
        );

        // ============================================
        // MESSAGE INTERCEPTORS
        // ============================================

        // Intercept LOAD request
        playerManager.setMessageInterceptor(
          cast.framework.messages.MessageType.LOAD,
          (loadRequestData) => {
            log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            log("üì® LOAD REQUEST INTERCEPTED");
            log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            log("Full request:", JSON.stringify(loadRequestData, null, 2));

            if (loadRequestData.media) {
              log("Media URL:", loadRequestData.media.contentId);
              log("Content Type:", loadRequestData.media.contentType);

              if (loadRequestData.media.tracks) {
                log("Tracks in request:", loadRequestData.media.tracks.length);
                loadRequestData.media.tracks.forEach((track, i) => {
                  log(`  Track ${i}:`, track);
                });
              }

              if (loadRequestData.media.customData) {
                log("Custom Data:", loadRequestData.media.customData);
              }
            }

            log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
            return loadRequestData;
          }
        );

        // ============================================
        // START RECEIVER
        // ============================================

        context.start(options);

        logSuccess("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        logSuccess("‚úÖ RECEIVER STARTED SUCCESSFULLY");
        logSuccess("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        logSuccess("Waiting for media to cast...");

        updateDebug("status", "Ready", "success");

        // Show debug panel if enabled
        if (DEBUG) {
          document.getElementById("debug").classList.remove("hidden");
          log("üêõ Debug panel visible");
        }
      } catch (error) {
        logError("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        logError("‚ùå FATAL ERROR: Failed to initialize receiver");
        logError("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        logError("Error message:", error.message);
        logError("Error stack:", error.stack);
        updateDebug("status", "FATAL ERROR", "error");
        updateLastError(`Init failed: ${error.message}`);
      }
    </script>
  </body>
</html>
